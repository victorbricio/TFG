<!DOCTYPE html>
<html>
<head>
	<style>
		h1 {text-align: center;}
		ol {text-align: center;}
		p {text-align: center;}
</style>
</head>
<body>

<p>
<canvas id="canvas1" width="1000" height="700"></canvas></td>
</p>
	<script type="text/javascript" src="Circunferencia.js"></script>
	<script type="text/javascript" src="Complex.js"></script>
	<script type="text/javascript" id="fuente">

	let p, q, nLayers;

	let centro, centro0, escala,

	canvas = document.getElementById('canvas1'),
	ctx = canvas.getContext('2d'),


	///// Variables globales de la geometria
	ReflectEdgeBisector,
	ReflectPgonEdge,
	cosh_b,
	RotateP,
	RotateQ,
	RotateEdge,
	Identity = [[1,0,0], [0,1,0], [0,0,1]];
	/*Tr,
	RotateCenter,
	RotateVertex;*/

		 ///
		// Definición de los vectores X, Y y Action
		///

		var X, Y, X1, Y1, Action;

		var color1, color2, border = 0;

		var rectaActual, puntoActual, puntoAnterior, sentido = 1;

		ctx.clearRect(0, 0, canvas.width, canvas.height);
		X = [], Y = [], X1 = [], Y1 = [], Action = [];
		//rectaActual = undefined, puntoActual = undefined;

		p = 10, q = 5, 		// parámetros p y q

		nLayers = 0;			// Capas a dibujar

	 centro = {x: 500, y: 350},
	 centro0 = {x: 0, y: 0},		/// Centrar las rotaciones en el centro
	 escala = 300;

	 		// Variables numéricas del artículo
	 		/*let a = 1 - Math.tan(Math.PI / p) * Math.tan(Math.PI / q),												//// Variable de apoyo
	 			 	s = Math.sqrt(a / (2 - a)),																											//// Vértice hiperbólico
	 				h = s / a,																																			//// Altura del centro del lado de un polígono
	 				r = Math.sqrt(h * h / ((Math.cos(Math.PI / p) * Math.cos(Math.PI / p))) - 1);		//// Radio de la circunferencia de un lado de un polígono

	 		//console.log(s);
	 		X.push(0);
	 		Y.push(s);*/

		if (border == 0 || border == 2){
	 		var vertice = verticePoligonoCentral();

	 		X.push(vertice.x);
	 		Y.push(vertice.y);
	 		//Action.push("Move");

	 		for (let i = 1; i < p + 1; i++){
	 			puntoRotado = rotatePoint(Y[0], X[0], 2 * Math.PI / p * i, centro0);
	 			Y.push(puntoRotado.x);
	 			X.push(puntoRotado.y);
	 			//Action.push("Draw");
			}
		}

 		let				//// Create ReflectEdgeBisector
 		RB1 = [1,0,0],
 		RB2 = [0,-1,0],
 		RB3 = [0,0,1];

 		ReflectEdgeBisector = [RB1, RB2, RB3],				//// End creation	/// ReflectQ para 1986

 		cosh_b = Math.cos(Math.PI / q) / Math.sin(Math.PI / p);		//// Create ReflectPgonEdge

 		let
 		cosh_2b = 2 * cosh_b * cosh_b - 1,
 		sinh_2b = Math.sqrt(cosh_2b * cosh_2b - 1),
 		RPE1 = [-cosh_2b, 0, sinh_2b],
 		RPE2 = [0, 1, 0],
 		RPE3 = [-sinh_2b, 0, cosh_2b];

 		ReflectPgonEdge = [RPE1, RPE2, RPE3];				//// End creation	/// ReflectP para el 1986

 		let											/// Create ReflectHypotenuse
 		RH1 = [Math.cos(2 * Math.PI / p), Math.sin(2 * Math.PI / p), 0],
 		RH2 = [Math.sin(2 * Math.PI / p), - Math.cos(2 * Math.PI / p), 0],
 		RH3 = [0, 0, 1];

 		ReflectHypotenuse = [RH1, RH2, RH3];				/// End creation	// Reflect2 para 1986


 		RotateP = matrixproduct(ReflectHypotenuse, ReflectEdgeBisector);		// 2 * Q
 		RotateQ = matrixproduct(ReflectPgonEdge, ReflectHypotenuse);			// P * 2
 		//RotateEdge = matrixproduct(ReflectPgonEdge, ReflectEdgeBisector);		// RotateEdge 1981 (este no está en 1986)

		//******************************************************************
		// llamada a la función principal

		//main();

		const board_border = 'black';
		const board_background = "white";
		const snake_col = 'lightblue';
		const snake_border = 'darkblue';

		let paso = 0.04;
		let changing_direction = false;
		let puntoActualPoincare;
		let cambio = false;

		let snake = [{x: centro.x, y: centro.y},  {x: centro.x - 10, y: centro.y},
								 {x: centro.x - 20, y: centro.y},  {x: centro.x - 30, y: centro.y}];

		if (rectaActual == undefined){
			rectaActual = new Circunferencia(centro.x + escala, centro.y, centro.x - escala, centro.y, ctx, centro, escala, "Black", 1);
		}

		if (puntoActual == undefined){
			puntoActual = centro;
			puntoAnterior = centro;
		}

		main2();

		document.addEventListener("keydown", change_direction);

		function main2() {
				changing_direction = false;
        setTimeout(function onTick() {
        clearCanvas();
        move_snake();
        drawSnake();
				//console.log(puntoActual);
        // Call main again
        main2();
      }, 400);
    }

		// draw a border around the canvas
		function clearCanvas() {
		  //  Select the colour to fill the drawing
		  ctx.fillStyle = board_background;
		  //  Select the colour for the border of the canvas
		  ctx.strokestyle = board_border;
		  // Draw a "filled" rectangle to cover the entire canvas
		  ctx.fillRect(0, 0, canvas.width, canvas.height);
		  // Draw a "border" around the entire canvas
		  ctx.strokeRect(0, 0, canvas.width, canvas.height);

			main();

			rectaActual.drawHyperbolicLine();
			puntoActualPoincare = {x: linealTransformationInverse(puntoActual.x, escala, centro.x),
														 y: linealTransformationInverse(puntoActual.y, escala, centro.y)};
			rectaActual.perpendicular(puntoActualPoincare).drawHyperbolicLine();
		}

		// Draw the snake on the canvas
		function drawSnake() {
		  // Draw each part
		  snake.forEach(drawSnakePart);
		}

		// Draw one snake part
		function drawSnakePart(snakePart) {

		  // Set the colour of the snake part
		  ctx.fillStyle = snake_col;
		  // Set the border colour of the snake part
		  ctx.strokestyle = snake_border;
		  // Draw a "filled" rectangle to represent the snake part at the coordinates
		  // the part is located
		  ctx.fillRect(snakePart.x, snakePart.y, 10, 10);
		  // Draw a border around the snake part
		  ctx.strokeRect(snakePart.x, snakePart.y, 10, 10);
		}

		function move_snake() {
			var xCoor, yCoor, t;

			if (rectaActual.isDiameter()){
				let vector_actual = {x:rectaActual.B().x - rectaActual.A().x,
														 y:rectaActual.B().y - rectaActual.A().y};

				let circunferenceAux = makeHyperbolicCircunference(puntoActual, paso, centro, escala);
 				circunferenceAux.radio *= escala;

				ctx.beginPath();
	   	  ctx.arc(circunferenceAux.centro.x, circunferenceAux.centro.y, circunferenceAux.radio, 0, 2 * Math.PI, false);
	   	  ctx.strokeStyle = 'Purple';
	   	  ctx.stroke();

				let puntos = interseccion_recta_con_circunferencia(vector_actual, rectaActual.A(), circunferenceAux.centro, circunferenceAux.radio);

				let t1 = (puntos.x.x - rectaActual.A().x) / vector_actual.x;
				let t2 = (puntos.y.x - rectaActual.A().x) / vector_actual.x;

				let tmax, tmin;

				if (t1 > t2){
					tmax = t1;
					tmin = t2;
				}

				else {
					tmax = t2;
					tmin = t1;
				}

				if ((sentido == 1 /*&& tmax == t1) || (sentido == -1 && tmax == t2*/)){
					xCoor = puntos.x.x;
					yCoor = puntos.x.y;
				}

				else {
					xCoor = puntos.y.x;
					yCoor = puntos.y.y;
				}
			}

			else {
				var circunferenceAux = makeHyperbolicCircunference(puntoAnterior, paso, centro, escala);
				circunferenceAux.radio *= escala;

				ctx.beginPath();
	   	  ctx.arc(circunferenceAux.centro.x, circunferenceAux.centro.y, circunferenceAux.radio, 0, 2 * Math.PI, false);
	   	  ctx.strokeStyle = 'Purple';
	   	  ctx.stroke();

				let puntos = interseccion_circunferencia_con_circunferencia(circunferenceAux.centro, circunferenceAux.radio,
																																		rectaActual.center(), rectaActual.radius());

				let t1 = angle(rectaActual.center().x, rectaActual.center().y, puntos.x.x, puntos.x.y);
				let t2 = angle(rectaActual.center().x, rectaActual.center().y, puntos.y.x, puntos.y.y);
				let tmax, tmin;

				if (t1 - t2 > 3 / 2 * Math.PI){
					t1 -= 2 * Math.PI;
				}

				if (t2 - t1 > 3 / 2 * Math.PI){
					t2 -= 2 * Math.PI;
				}

				if (t1 > t2){
					tmax = t1;
					tmin = t2;
				}

				else {
					tmax = t2;
					tmin = t1;
				}
				if ((sentido == 1 /*&& tmax == t1) || (sentido == -1 && tmax == t2*/)){
					xCoor = puntos.x.x;
					yCoor = puntos.x.y;
				}

				else {
					xCoor = puntos.y.x;
					yCoor = puntos.y.y;
				}
			}

			puntoAnterior = puntoActual;

      // Create the new Snake's head
      const head = {x: xCoor, y: yCoor};
			puntoActual = head;

			if (cambio){
				puntoAnterior = puntoActual;
				cambio = false;
			}

			//console.log(sentido);

      // Add the new head to the beginning of snake body
      snake.unshift(head);
      snake.pop();
    }

		function change_direction(event) {
      const LEFT_KEY = 37;
      const RIGHT_KEY = 39;

      if (changing_direction)
				return;
      changing_direction = true;

      const keyPressed = event.keyCode;

      if (keyPressed === LEFT_KEY) {
        rectaActual = rectaActual.perpendicular(puntoActualPoincare);
				sentido = 1;
				cambio = true;
      }

      if (keyPressed === RIGHT_KEY) {
        rectaActual = rectaActual.perpendicular(puntoActualPoincare);
				sentido = -1;
				cambio = true;
      }
		}


	function verticePoligonoCentral(){
		let sin = Math.sin(Math.PI / p);
		let cos = Math.cos(Math.PI / q);
		let radio = 1 / Math.sqrt(((cos * cos) / (sin * sin)) - 1);
		let distancia_entre_centros = 1 / Math.sqrt(1 - ((sin * sin) / (cos * cos)));

		let t = Math.tan(Math.PI / p);
		let n = centro0.y - t * centro0.x;

		var a = 1 + t * t;
		var b = 2 * (- distancia_entre_centros + t * n);
		var c = distancia_entre_centros * distancia_entre_centros + n * n - radio * radio;

		var x1 = (- b + Math.sqrt( b * b - 4 * a * c)) / ( 2 * a);
		var y1 = t * x1 + n;

		var x2 = (- b - Math.sqrt( b * b - 4 * a * c)) / ( 2 * a);
		var y2 = t * x2 + n;

		var mod1 = (x1 - centro.x) * (x1 - centro.x) + (y1 - centro.y) * (y1 - centro.y);
		var mod2 = (x2 - centro.x) * (x2 - centro.x) + (y2 - centro.y) * (y2 - centro.y);

		var x;

		if (mod1 > mod2){
			x = {x: x1, y: y1};
		}

		else {
			x = {x: x2, y: y2};
		}

		return x;
	 }

	//**********************************************************************
	// Hace una transformacion lineal
	// Una homotecia con:
	// punto: el punto a trasladar
	// escala: la escala de la homotecia
	// centro: centro de la homotecia

	function linealTransformation(punto, escala, centro){
		return punto * escala + centro;
	}

	function linealTransformationInverse(punto, escala, centro){
		return (punto - centro) / escala;
	}

  function getPoint01(punto, r, c){
    var x = linealTransformationInverse(punto.x, r, c.x);
    var y = linealTransformationInverse(punto.y, r, c.y);

    var ret = {x:x, y:y};

    return ret;
  }

  function MobiusTransformation(z, punto){
    var zComp = new Complex(z.x, z.y);
    var puntoComp = new Complex(punto.x, punto.y);
    var uno = new Complex(1, 0);

    var res = div(sub(zComp, puntoComp), sub(uno, prod(conjg(puntoComp), zComp)));
    res = {x: res.re(), y: res.im()};

    return res;
  }

  function MobiusTransformationBack(z, punto){
    var zComp = new Complex(z.x, z.y);
    var puntoComp = new Complex(punto.x, punto.y);
    var uno = new Complex(1, 0);

    var res = div(add(zComp, puntoComp), add(uno, prod(conjg(puntoComp), zComp)));
    res = {x: res.re(), y: res.im()};

    return res;
  }

	// Obtiene el ángulo con la horizontal que tiene el punto (x,y) en una circunferencia de centro (cx, cy)
  function angle(cx, cy, x, y) {
     var dx = x - cx;
     var dy = y - cy;
     var theta = Math.atan2(dy, dx); // range (-PI, PI]

     if (theta < 0)
        theta += 2 * Math.PI
     return theta;
   }

	//**********************************************************************

	// x e y: son las coordenadas del punto a rotar
	// alpha: es el ángulo en radianes que queremos rotar el punto
	// centro: es el centro de la rotación

	function rotatePoint(x, y, alpha, centro) {
		let sin = Math.sin(alpha);
		let cos = Math.cos(alpha);

		// Trasladar al centro
		x -= centro.x;
		y -= centro.y;

		// Rotar
		let newX = x * cos - y * sin;
		let newY = x * sin + y * cos;

		// Trasladar de vuelta
		let punto = {x: newX + centro.x, y: newY + centro.y};

		return punto;
	}


	//**********************************************************************

	// Supongo que mat1 es 3x3 y mat2 va a ser 3x3 o 3x1

	function matrixproduct( mat1, mat2 )
	{
		if (mat2[0].length == 3)
			var matrizRes = [[0,0,0], [0,0,0], [0,0,0]];

		else if (mat2[0].length == 1)
			var matrizRes = [[0], [0], [0]];

   		for (let i = 0; i < mat1.length; i++){
				for (let j = 0; j < mat2[0].length; j++){
					for (let k = 0; k < mat2.length; k++){
				 		matrizRes[i][j] += (mat1[i][k] * mat2[k][j]);
					}
				}
			}

			return matrizRes;
    }

	//**********************************************************************

	function elementoHTML( id )
	{
		let elem = document.getElementById( id ) ;

		if ( ! elem )
			{
				alert('error: no hay en el documento un elemento html con identificador igual a "'+id+"'");
		   	exit() ;
			}
		return elem ;
	}

	// LLeva un punto del disco de Poincaré al modelo de Weierstrass
	function applyG(x, y){
		return  [[(2 * x) / (1 - x * x - y * y)],
			 [(2 * y) / (1 - x * x - y * y)],
			 [(1 + x * x + y * y) / (1 - x * x - y * y)]];
	}

	// LLeva un punto del modelo de Weierstrass al disco de Poincaré
	function applyF(x, y, z){
		return [[x / (1 + z)],
						[y / (1 + z)]];
	}

	//*******************************************************************************************

	function DrawPgonPattern(transformation){

		var
		Tvertex, oldTvertex, Tcenter;

		/// Centro del polígono
		let weierstrassCoordinatesCenter = applyG(centro0.x, centro0.y);

		let TCenter = matrixproduct(transformation, weierstrassCoordinatesCenter);

		Tcenter = applyF(TCenter[0][0], TCenter[1][0], TCenter[2][0]);

		Tcenter[0][0] = linealTransformation(Tcenter[0][0], escala, centro.x);
		Tcenter[1][0] = linealTransformation(Tcenter[1][0], escala, centro.y);

		if (border == 0 || border == 2){
			for (let i = 0; i < X.length; i++){

					/// Vertices del polígono
					let weierstrassCoordinates = applyG(X[i], Y[i]);
					let Z = matrixproduct(transformation, weierstrassCoordinates);

					Tvertex = applyF(Z[0][0], Z[1][0], Z[2][0]);

					Tvertex[0][0] = linealTransformation(Tvertex[0][0], escala, centro.x);
					Tvertex[1][0] = linealTransformation(Tvertex[1][0], escala, centro.y);

					if (i != 0){
						/// Lados del polígono
						var lineaHiperbolica = new Circunferencia(oldTvertex[0][0], oldTvertex[1][0], Tvertex[0][0], Tvertex[1][0], ctx,
							centro, escala, "Red", 1);
						lineaHiperbolica.drawHyperbolicLine();

						/// Radios del polígono
						var lineaHiperbolicaCenter = new Circunferencia(Tcenter[0][0], Tcenter[1][0], Tvertex[0][0], Tvertex[1][0], ctx, centro,
							escala, "Grey", 1);
						lineaHiperbolicaCenter.drawHyperbolicLine();

						/*console.log(oldTx);
						console.log(oldTy);
						console.log(Tx);
						console.log(Ty);*/
					}

					oldTvertex = Tvertex;
			}
		}

		if (border == 1 || border == 2){
			for (let i = 0; i < X1.length; i++){
				if (i == 0)
					ctx.beginPath();
				let weierstrassCoordinates = applyG(X1[i], Y1[i]);
				let Z1 = matrixproduct(transformation, weierstrassCoordinates);

				Tvertex = applyF(Z1[0][0], Z1[1][0], Z1[2][0]);

				Tvertex[0][0] = linealTransformation(Tvertex[0][0], escala, centro.x);
				Tvertex[1][0] = linealTransformation(Tvertex[1][0], escala, centro.y);

				switch(Action[i]){
					case "Move":
						ctx.moveTo(Tvertex[0][0], Tvertex[1][0]);
						//console.log(`ctx.moveTo(${Tvertex[0][0]},${Tvertex[1][0]})`)
						break;

					case "Draw":
						ctx.lineTo(Tvertex[0][0], Tvertex[1][0]);
						//console.log(`ctx.lineTo(${Tvertex[0][0]},${Tvertex[1][0]})`)
						break;

					default:
						ctx.strokeStyle = Action[i];		//Pinta los bordes del polígono
						ctx.stroke();
						if (i != X1.length)
							ctx.beginPath();
						//console.log(`Black == ctx.stroke() ; ctx.beginPath()`)
						break;
				}
			}
		}

	}

	//*******************************************************************************************

	function ReplicatePattern(InitialTransformation, Layerdiff, Adyacency){
		let
		RotateCenter,
		RotateVertex,
		//Tr,										/// Esta variable está definida en el artículo de 1981
		i, j,
		ExposedEdges,
		PgonsPerVertex;

		DrawPgonPattern(InitialTransformation);

		if (Layerdiff > 0){

			var Rotate2P = matrixproduct(RotateP, RotateP);

			if (Adyacency == "Edge"){
				ExposedEdges = p - 3;
				var Rotate3P = matrixproduct(Rotate2P, RotateP);

				RotateCenter = matrixproduct(InitialTransformation,	Rotate3P);	//// Esto está en el artículo de 1986
			}

			else if (Adyacency == "Vertex"){
				ExposedEdges = p - 2;

				RotateCenter = matrixproduct(InitialTransformation, Rotate2P);		//// Esto está en el artículo de 1986
			}

			else {
				throw RangeError(`Adyacency has an incorrect value`);
			}

			/*RotateCenter = matrixproduct(						///RotateP * RotateP * InitialTransformation
				matrixproduct(RotateP, RotateP),				/// Esto está en el artículo de 1981
				InitialTransformation);*/

			for (i = 0; i < ExposedEdges; i++){
				RotateVertex = matrixproduct(RotateCenter, RotateQ);			/// Esto está en el artículo de 1986

				ReplicatePattern(RotateVertex,
												Layerdiff - 1,
												"Edge");			/// Esto está en el artículo de 1986

				if (i < ExposedEdges - 1)					//// El -1 es para compensar que la i empieza en 0
					PgonsPerVertex = q - 3;

				else if (i == ExposedEdges - 1)					//// El -1 es para compensar que la i empieza en 0
					PgonsPerVertex = q - 4;


			for(j = 0; j < PgonsPerVertex; j++){
				RotateVertex = matrixproduct(RotateVertex, RotateQ);
				ReplicatePattern(RotateVertex,
					Layerdiff - 1,
					"Vertex");
			}

			RotateCenter = matrixproduct(RotateCenter, RotateP);		/// Este for, junto con esta línea, están en el artículo de 1986

			}
		}
	}

	//*******************************************************************************************
	// función principal (la introduzco para poder poner 'return' antes de que acabe)

	function main()
	{
		var
		RotateCenter,
		RotateVertex;

		// Disco de Poincaré
 	 ctx.beginPath();
 	 ctx.arc(centro.x, centro.y, escala, 0, 2 * Math.PI, false);
 	 ctx.strokeStyle = 'Blue';
 	 ctx.stroke();

		//console.log(`X.length == ${X1.length}, p == ${p}`);

		//console.log(`main(): p == ${p}`);

		if (border == 1 || border == 2){
			// Le añado un (0,0) a los puntos puesto que cuando llegue a este punto se eligirá el color
			X1.push(0);
			Y1.push(0);
			Action.push("Purple");  // CUA: mejor adoptar política siempre tres 'Push' paralelos

			const long_X_orig = X1.length;

			if ( X1.length != Y1.length || X1.length != Action.length )
				throw RangeError(`las longitudes de X/Y/Action no coinciden, están mal definidas`)


		 /// Añado las rotaciones a los vectores X e Y (y Action)
		 for (let i = 1; i < p; i++){   // cambiar 'var' por 'let'
			 for (let j = 0; j < long_X_orig; j++){     // CUA usar 'X.length' en lugar de exactamente '6'
				 let puntoRotado = {x:0, y:0};

				 if (j != long_X_orig - 1)				// Cuando sea Negro, se añade el punto (0,0)
				 		puntoRotado = rotatePoint(X1[j], Y1[j], 2 * Math.PI / p * i, centro0);  // const en lugar de 'var'

				 X1.push(puntoRotado.x);
				 Y1.push(puntoRotado.y);
				 Action.push(Action[j]) ; //  CUA: mejor adoptar política siempre tres 'Push' paralelos
			 }
		 }
	 }

		 DrawPgonPattern(Identity);



			if (nLayers > 0){					/// Para poder dibujar solo la primera capa (la capa 0)
	

			RotateCenter = Identity;

			for (let i = 0; i < p; i++){
				RotateVertex = matrixproduct(RotateCenter, RotateQ);

				ReplicatePattern(RotateVertex, nLayers - 1, "Edge");			// En el artículo de 1986 pone nLayers - 2, me parece más lógico con -1

				for (let j = 0; j < q - 3; j++){
					RotateVertex = matrixproduct(RotateVertex, RotateQ);
					ReplicatePattern(RotateVertex, nLayers - 1, "Vertex");		// En el artículo de 1986 pone nLayers - 2, me parece más lógico con -1
				}

				RotateCenter = matrixproduct(RotateCenter, RotateP);
			}
		}
	}

</script>
</body>
</html>
