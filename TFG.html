
<!DOCTYPE html>
<html>
<head>
</head>
<body>

<p>
<canvas id="canvas1" width="1000" height="700"></canvas></td>
</p>
	<script type="text/javascript" id="fuente">

	var
	//// Variables globales del canvas
	// Estas variables que están comentadas las cogí del código que me proporcionaste.
	// Pero puesto que con las dos últimas funciona bien lo he dejado así.
	/*ctx,
	ctx_doc,
	ctx_aux,
	canv_doc,
	canv_aux,
	tcx,
	tcy,*/
	canvas = document.getElementById('canvas1'),
	ctx = canvas.getContext('2d'),



	///// Variables globales de la geometria
	ReflectEdgeBisector,
	ReflectPgonEdge,
	cosh_b,
	RotateP,
	RotateQ,
	RotateEdge,
	Identity = [[1,0,0], [0,1,0], [0,0,1]],
	Tr,
	RotateCenter,
	RotateVertex;


	var p = 6, q = 4, 		// parámetros p y q
			nLayers = 2;			// Capas a dibujar


	var										//// Create ReflectEdgeBisector
	RB1 = [1,0,0],
	RB2 = [0,-1,0],
	RB3 = [0,0,1];


	ReflectEdgeBisector = [RB1,RB2,RB3];	//// End creation



	cosh_b = Math.cos(Math.PI / q) / Math.sin(Math.PI / p);		//// Create ReflectPgonEdge

	var
	cosh_2b = 2 * cosh_b * cosh_b - 1,
	sinh_2b = Math.sqrt(cosh_b * cosh_b - 1),
	RPE1 = [-cosh_2b, 0, sinh_2b],
	RPE2 = [0, 1, 0],
	RPE3 = [-sinh_2b, 0, cosh_2b];

	ReflectPgonEdge = [RPE1, RPE2, RPE3];						//// End creation

	//console.log("cos2 = " + cosh_2b);
	//console.log("sin = " + sinh_2b);
	//console.log("cosh_b: " + cosh_b);


	var																							/// Create ReflectHypotenuse
	RH1 = [Math.cos(2 / p), Math.sin(2 / p), 0],
	RH2 = [Math.sin(2 / p), -Math.cos(2 / p), 0],
	RH3 = [0, 0, 1];

	ReflectHypotenuse = [RH1, RH2, RH3];						/// End creation


	RotateP = matrixproduct(ReflectEdgeBisector, ReflectHypotenuse);
	RotateQ = matrixproduct(ReflectHypotenuse, ReflectPgonEdge);
	RotateEdge = matrixproduct(ReflectPgonEdge, ReflectEdgeBisector);

	//**********************************************************************

	// x e y: son las coordenadas del punto a rotar
	// alpha: es el ángulo en radianes que queremos rotar el punto
	// centro: es el centro de la rotación

	function rotatePoint(x, y, alpha, centro) {
		var sin = Math.sin(alpha);
		var cos = Math.cos(alpha);

		// Trasladar al centro
		x -= centro.x;
		y -= centro.y;

		// Rotar
		var newX = x * cos - y * sin;
		var newY = x * sin + y * cos;

		// Trasladar de vuelta
		var p = {x: newX + centro.x, y: newY + centro.y};

		return p;
	}

	//**********************************************************************

	// Supongo que mat1 es 3x3 y mat2 va a ser 3x3 o 3x1

	function matrixproduct( mat1, mat2 )
	{
		if (mat2[0].length == 3)
			var matrizRes = [[0,0,0], [0,0,0], [0,0,0]];

		else if (mat2[0].length == 1)
			var matrizRes = [[0], [0], [0]];

   		for (var i = 0; i < mat1.length; i++){
			for (var j = 0; j < mat2[0].length; j++){
				for (var k = 0; k < mat2.length; k++){
				 	matrizRes[i][j] += (mat1[i][k] * mat2[k][j]);
				}
			}
		}

		return matrizRes;
    }

	//**********************************************************************

	function elementoHTML( id )
	{
		var elem = document.getElementById( id ) ;

		if ( ! elem )
			{
				alert('error: no hay en el documento un elemento html con identificador igual a "'+id+"'");
		   	exit() ;
			}
		return elem ;
}

	//**********************************************************************

	// Esta función no se utiliza ahora mismo, las definiciones están hechas de forma global.

	function inicialice( p, q ){
	/*canv_doc = elementoHTML("canvas1");

	ctx_doc = canv_doc.getContext("2d");

	if (!ctx_doc){
		alert("error: la llamada a canv_doc.getContext(\"2d\") no está soportada o no ha funcionado.");
		exit();
		}

	tcx = canv_doc.width,		/// Tamaño del canvas en la X
	tcy = canv_doc.height;		/// Tamaño del canvas en la Y


	canv_aux = document.createElement('canvas');

	if (!canv_aux){
		alert("error: la llamada a document.createElement('canvas') no está soportada o no ha funcionado.");
		exit();
		}

	canv_aux.width = tcx;
	canv_aux.height = tcy;

	ctx_aux = canv_aux.getContext('2d');

	if (!canv_aux){
		alert("error: la llamada a canv_aux.getContext('2d') no está soportada o no ha funcionado.");
		exit();
		}

	// Se dibuja en el canvas auxiliar.
	ctx = ctx_aux;*/



	var										//// Create ReflectEdgeBisector
	RB1 = [1,0,0],
	RB2 = [0,-1,0],
	RB3 = [0,0,1];


	ReflectEdgeBisector = [RB1,RB2,RB3];	//// End creation



	cosh_b = Math.cos(Math.PI / q) / Math.sin(Math.PI / p);		//// Create ReflectPgonEdge

	var
	cosh_2b = 2 * cosh_b * cosh_b - 1,
	sinh_2b = Math.sqrt(cosh_b * cosh_b - 1),
	RPE1 = [-cosh_2b, 0, sinh_2b],
	RPE2 = [0, 1, 0],
	RPE3 = [-sinh_2b, 0, cosh_2b];

	ReflectPgonEdge = [RPE1, RPE2, RPE3];						//// End creation

	//console.log("cos2 = " + cosh_2b);
	//console.log("sin = " + sinh_2b);
	//console.log("cosh_b: " + cosh_b);


	var																							/// Create ReflectHypotenuse
	RH1 = [Math.cos(2 / p), Math.sin(2 / p), 0],
	RH2 = [Math.sin(2 / p), -Math.cos(2 / p), 0],
	RH3 = [0, 0, 1];

	ReflectHypotenuse = [RH1, RH2, RH3];						/// End creation


	RotateP = matrixproduct(ReflectEdgeBisector, ReflectHypotenuse);
	RotateQ = matrixproduct(ReflectHypotenuse, ReflectPgonEdge);
	RotateEdge = matrixproduct(ReflectPgonEdge, ReflectEdgeBisector);

	}

	//*******************************************************************************************

	function DrawPgonPattern(transformation){
		var
		SumSquare,
		Tx, Ty;

		for (i = 0; i < Action.length /*nPgonActions*/; i++){
			console.log("iteracion: " + i);
			if (Action[i] != "Black"){													// Ahora mismo el único color que hay es Negro
				SumSquare = X[i] * X[i] + Y[i] * Y[i];

				var Z = [[2 * X[i] / (1 - SumSquare)],
								[2 * Y[i] / (1 - SumSquare)],
								[(1 + SumSquare) / (1 - SumSquare)]];

				//console.log("Antes: " + Z);

				Z = matrixproduct(transformation, Z);

				//console.log("Despues: " + Z);

				Tx = Z[0][0] / (1 + Z[2][0]);
				Ty = Z[1][0] / (1 + Z[2][0]);

				console.log("Tx: " + Tx);
				console.log("Ty: " + Ty);
			}

			switch(Action[i]){
				case "Move":
					ctx.moveTo(Tx, Ty);
					break;

				case "Draw":
					ctx.lineTo(Tx, Ty);
					break;

				case "Black":
					ctx.strokeStyle = "Black";		//Pinta los bordes del polígono
					ctx.stroke();
					break;

				case "Blue":
					ctx.strokeStyle = "Blue";
					ctx.stroke();
					break;

				case "Red":
					ctx.strokeStyle = "Red";
					ctx.stroke();
					break;

				case "Yellow":
					ctx.strokeStyle = "Yellow";
					ctx.stroke();
					break;
			}
		}
	}

	//*******************************************************************************************

	function ReplicatePatern(InitialTransformation, Layerdiff, Adyacency){
		var
		RotateCenter,
		RotateVertex,
		Tr,
		i, j,
		ExposedEdges = 0,
		PgonsPerVertex = 0;

		DrawPgonPattern(InitialTransformation);

		if (Layerdiff > 0){
			if (Adyacency == "Edge")
				ExposedEdges = p - 3;

			else if (Adyacency == "Vertex")
				ExposedEdges = p - 2;
			}

		RotateCenter = matrixproduct(									///RotateP * RotateP * InitialTransformation
			matrixproduct(RotateP, RotateP),
			InitialTransformation);

		for (i = 0; i < ExposedEdges; i++){
			Tr = matrixproduct(RotateEdge, RotateCenter);

			console.log("Nueva matriz a aplicar a ReplicatePatern");
			console.log(Tr);

			if(Layerdiff > 0)
				ReplicatePatern(Tr, Layerdiff - 1, "Edge");

			RotateCenter = matrixproduct(RotateP, RotateCenter);

			if (i < ExposedEdges - 1)									//// El -1 es para compensar que la i empieza en 0
				PgonsPerVertex = q - 3;

			else if (i == ExposedEdges - 1)						//// El -1 es para compensar que la i empieza en 0
				PgonsPerVertex = q - 4;

			RotateVertex = matrixproduct(RotateQ, RotateP);

			for(j = 0; j < PgonsPerVertex; j++){

				if(Layerdiff > 0)
					ReplicatePatern(
						matrixproduct(RotateVertex, Tr),
						Layerdiff - 1,
						"Vertex");

				RotateVertex = matrixproduct(RotateQ, RotateVertex);
			}
		}
	}

	//*******************************************************************************************
	// Esta función es para probar pintar normal, funciona bien
	// No se usa ahora mismo

	function draw(){
		var canvas = document.getElementById('canvas1');
		var prueba = ["Move", "Draw1", "Draw2", "Black", "Move1", "Draw3", "Red"];

		if(canvas.getContext){
			var ctx = canvas.getContext('2d');

			ctx.beginPath();
			for (var i = 0; i < prueba.length; i++){
				switch(prueba[i]){														////
					case "Move":
						ctx.moveTo(350, 350);
						break;

					case "Move1":
						ctx.moveTo(600, 600);
						break;

					case "Draw1":
						ctx.lineTo(100, 200);
						break;

					case "Black":
						ctx.strokeStyle = "Black";		//Pinta los bordes del polígono
						ctx.stroke();									/// Aun poniéndolo así, los dos segmentos salen rojos, el último color es rojo
						break;

					case "Red":
						ctx.strokeStyle = "Red";		//Pinta los bordes del polígono
						ctx.stroke();								/// Aun poniéndolo así, los dos segmentos salen rojos, el último color es rojo
						break;

					case "Draw2":
						ctx.lineTo(200, 200);
						break;

					case "Draw3":
						ctx.lineTo(650, 600);
						break;
				}
			}
		}

	}

	//draw();

	 ///
	 // Definición de los vectores X, Y y Action
	 ///

	 var puntos = {x0: 2.7, y0: -1.3, x1: 4.5, y1: -.45,
		 						 x2: 5.4, y2: 2, x3: 4.9, y3: 1.75,
							 	 x4: 2.49, y4: 1.85, x5: 2.4, y5:.8},
			 centro = {x: 600, y: 350},
			 escala = 20;

// Enlace de Geogebra para ver los puntos originales
// https://www.geogebra.org/geometry/wcx98k6u

		// Los vectores X e Y toman los puntos que están definidos en Geogebra, les aplica la escala y los traslada al centro
 	 var X = [puntos.x0 * escala + centro.x, puntos.x1 * escala + centro.x,
		 				puntos.x2 * escala + centro.x, puntos.x3 * escala + centro.x,
						puntos.x4 * escala + centro.x, puntos.x5 * escala + centro.x],
 			 Y = [puntos.y0 * escala + centro.y, puntos.y1 * escala + centro.y,
		 				puntos.y2 * escala + centro.y, puntos.y3 * escala + centro.y,
						puntos.y4 * escala + centro.y, puntos.y5 * escala + centro.y],
 	 Action = ["Move", "Draw", "Draw", "Draw", "Move", "Draw",
 						 "Move", "Draw", "Draw", "Draw", "Move", "Draw",
 						 "Move", "Draw", "Draw", "Draw", "Move", "Draw",
 						 "Move", "Draw", "Draw", "Draw", "Move", "Draw",
 						 "Move", "Draw", "Draw", "Draw", "Move", "Draw",
 						 "Move", "Draw", "Draw", "Draw", "Move", "Draw", "Black"];

	 /// Añado las rotaciones a los vectores X e Y
	 for (var i = 1; i < p; i++){
		 for (var j = 0; j < 6; j++){
			 var puntoRotado = rotatePoint(X[j], Y[j], Math.PI / 3 * i, centro);
			 X.push(puntoRotado.x);
			 Y.push(puntoRotado.y);
		 }
	 }

	 // Le añado un (0,0) a los puntos puesto que cuando llegue a este punto se eligirá el color
	 X.push(0);
	 Y.push(0);

   DrawPgonPattern(Identity);

	 RotateCenter = Identity;

   for(var i = 0; i < p; i++){
		Tr = matrixproduct(RotateEdge, RotateCenter);
		console.log("Matriz a aplicar al ReplicatePatern");
		console.log(Tr);

		ReplicatePatern(Tr, nLayers - 1, "Edge");

		RotateCenter = matrixproduct(RotateP, RotateCenter);
		RotateVertex = matrixproduct(RotateQ, RotateP);

		for (var j = 0; j < q - 3; j++){
				ReplicatePatern(
					matrixproduct(RotateVertex, Tr),
					nLayers - 1,
					"Vertex");

			RotateVertex = matrixproduct(RotateQ, RotateVertex);
		}
	}

	</script>
</body>
</html>
