<!DOCTYPE html>
<html>
<head>
</head>
<body>

<p>
<canvas id="canvas1" width="1000" height="700"></canvas>
</p>
	<script type="text/javascript" id="fuente">

	var
	canvas = document.getElementById('canvas1'),
	ctx = canvas.getContext('2d');

	var p = 6, q = 4, 		// parámetros p y q
	nLayers = 2;			// Capas a dibujar

	 var /*puntos = {x0: 0, y0: 3, x1: -2.6, y1: 1.5,
		 	x2: -2.6, y2: -1.5, x3: 0, y3: -3,
			x4: 2.6, y4: -1.5, x5: 2.6, y5:1.5},*/
	    centro = {x: 600, y: 375},
	    //centro0 = {x: 0, y: 0},				/// Centrar las rotaciones en el centro
	    escala = 250;

		//**********************************************************************
		// Hace una transformacion lineal

	function linealTransformation(punto, escala, centro){
		return punto * escala + centro;
	}

	//**********************************************************************

	// x e y: son las coordenadas del punto a rotar
	// alpha: es el ángulo en radianes que queremos rotar el punto
	// centro: es el centro de la rotación

	function rotatePoint(x, y, alpha, centro) {
		var sin = Math.sin(alpha);
		var cos = Math.cos(alpha);

		// Trasladar al centro
		x -= centro.x;
		y -= centro.y;

		// Rotar
		var newX = x * cos - y * sin;
		var newY = x * sin + y * cos;

		// Trasladar de vuelta
		var p = {x: newX + centro.x, y: newY + centro.y};

		return p;
	}

// Alert en el caso de que la teselación elegida no sea hiperbólica
if ((p - 2) * (q - 2) <= 4)
  window.alert("Esta teselación no es hiperbólica")

// Variables numéricas del artículo
let a = 1 - Math.tan(Math.PI / p) * Math.tan(Math.PI / q),					/// Variable de apoyo
    s = Math.sqrt(a / (2 - a)),									//// Vértice hiperbólico  (s,0)
    h = s / a,											//// Altura del centro del lado de un polígono
    r = Math.sqrt(h * h / (Math.cos(Math.PI / p) * Math.cos(Math.PI / p)) - 1);			//// Radio de la circunferencia de un lado de un polígono


/// Centro de las circunferiencias que forman los lados
let c = {x: linealTransformation(h, escala, centro.x), y: linealTransformation(h * Math.tan(Math.PI / p), escala, centro.y)};

// Disco de Poincaré (borde del disco)
ctx.beginPath();
ctx.arc(centro.x, centro.y, escala, 0, 2 * Math.PI, false);
ctx.strokeStyle = 'Blue';
ctx.stroke();


for (let i = 0; i < p; i++){
	ctx.beginPath();

	puntoRotado = rotatePoint(c.x, c.y, 2 * Math.PI / p * i, centro);
	ctx.arc(puntoRotado.x, puntoRotado.y, r * escala, 2 * Math.PI / p * (i + p / 2),  2 * Math.PI / p * (i + p / 2 + 1), false);
	ctx.strokeStyle = 'Black';
	ctx.stroke();
}

</script>
</body>
</html>
