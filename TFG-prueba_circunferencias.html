<!DOCTYPE html>
<html>
<head>
</head>
<body>

<p>
<canvas id="canvas1" width="1000" height="700"></canvas></td>
</p>
	<script type="text/javascript" src="Circunferencia.js"></script>
	<script type="text/javascript" id="fuente">

	let
	canvas = document.getElementById('canvas1'),
	ctx = canvas.getContext('2d'),


	///// Variables globales de la geometria
	ReflectEdgeBisector,
	ReflectPgonEdge,
	cosh_b,
	RotateP,
	RotateQ,
	RotateEdge,
	Identity = [[1,0,0], [0,1,0], [0,0,1]];

	let p = 7, q = 3, 		// parámetros p y q

	nLayers = 3;			// Capas a dibujar

	if ((p - 2) * (q - 2) <= 4)
  		window.alert("La teselación {" + p + "," + q + "} no es hiperbólica");

	let	 centro = {x: 600, y: 350},
		 centro0 = {x: 0, y: 0},		/// Centrar las rotaciones en el centro
		 escala = 250;


	function verticePoligonoCentral(){
		let sin = Math.sin(Math.PI / p);
		let cos = Math.cos(Math.PI / q);
		let radio = 1 / Math.sqrt(((cos * cos) / (sin * sin)) - 1);
		let distancia_entre_centros = 1 / Math.sqrt(1 - ((sin * sin) / (cos * cos)));

		let t = Math.tan(Math.PI / p);
		let n = centro0.y - t * centro0.x;

		var a = 1 + t * t;
		var b = 2 * (- distancia_entre_centros + t * n);
		var c = distancia_entre_centros * distancia_entre_centros + n * n - radio * radio;

		var x1 = (- b + Math.sqrt( b * b - 4 * a * c)) / ( 2 * a);
		var y1 = t * x1 + n;

		var x2 = (- b - Math.sqrt( b * b - 4 * a * c)) / ( 2 * a);
		var y2 = t * x2 + n;

		var mod1 = (x1 - centro.x) * (x1 - centro.x) + (y1 - centro.y) * (y1 - centro.y);
		var mod2 = (x2 - centro.x) * (x2 - centro.x) + (y2 - centro.y) * (y2 - centro.y);

		var x;

		if (mod1 > mod2){
			x = {x: x1, y: y1};
		}

		else {
			x = {x: x2, y: y2};
		}

		return x;
	 }

	///
	// Definición de los vectores X, Y y Action
	///

	var X = [], Y = [], Action = [];

	var vertice = verticePoligonoCentral();

	X.push(vertice.x);
	Y.push(vertice.y);
	Action.push("Move");

	for (let i = 1; i < p + 1; i++){
		puntoRotado = rotatePoint(Y[0], X[0], 2 * Math.PI / p * i, centro0);
		Y.push(puntoRotado.x);
		X.push(puntoRotado.y);
		Action.push("Draw");
	}

	let				//// Create ReflectEdgeBisector
	RB1 = [1,0,0],
	RB2 = [0,-1,0],
	RB3 = [0,0,1];

	ReflectEdgeBisector = [RB1, RB2, RB3],				//// End creation	/// ReflectQ para 1986

	cosh_b = Math.cos(Math.PI / q) / Math.sin(Math.PI / p);		//// Create ReflectPgonEdge

	let
	cosh_2b = 2 * cosh_b * cosh_b - 1,
	sinh_2b = Math.sqrt(cosh_2b * cosh_2b - 1),
	RPE1 = [-cosh_2b, 0, sinh_2b],
	RPE2 = [0, 1, 0],
	RPE3 = [-sinh_2b, 0, cosh_2b];

	ReflectPgonEdge = [RPE1, RPE2, RPE3];				//// End creation	/// ReflectP para el 1986

	let											/// Create ReflectHypotenuse
	RH1 = [Math.cos(2 * Math.PI / p), Math.sin(2 * Math.PI / p), 0],
	RH2 = [Math.sin(2 * Math.PI / p), - Math.cos(2 * Math.PI / p), 0],
	RH3 = [0, 0, 1];

	ReflectHypotenuse = [RH1, RH2, RH3];				/// End creation	// Reflect2 para 1986


	RotateP = matrixproduct(ReflectHypotenuse, ReflectEdgeBisector);		// 2 * Q
	RotateQ = matrixproduct(ReflectPgonEdge, ReflectHypotenuse);			// P * 2


	//**********************************************************************
	// Hace una transformacion lineal
	// Una homotecia con:
	// punto: el punto a trasladar
	// escala: la escala de la homotecia
	// centro: centro de la homotecia

	function linealTransformation(punto, escala, centro){
		return punto * escala + centro;
	}

	//**********************************************************************

	// x e y: son las coordenadas del punto a rotar
	// alpha: es el ángulo en radianes que queremos rotar el punto
	// centro: es el centro de la rotación

	function rotatePoint(x, y, alpha, centro) {
		let sin = Math.sin(alpha);
		let cos = Math.cos(alpha);

		// Trasladar al centro
		x -= centro.x;
		y -= centro.y;

		// Rotar
		let newX = x * cos - y * sin;
		let newY = x * sin + y * cos;

		// Trasladar de vuelta
		let punto = {x: newX + centro.x, y: newY + centro.y};

		return punto;
	}


	//**********************************************************************

	// Supongo que mat1 es 3x3 y mat2 va a ser 3x3 o 3x1

	function matrixproduct( mat1, mat2 )
	{
		if (mat2[0].length == 3)
			var matrizRes = [[0,0,0], [0,0,0], [0,0,0]];

		else if (mat2[0].length == 1)
			var matrizRes = [[0], [0], [0]];

   		for (let i = 0; i < mat1.length; i++){
				for (let j = 0; j < mat2[0].length; j++){
					for (let k = 0; k < mat2.length; k++){
				 		matrizRes[i][j] += (mat1[i][k] * mat2[k][j]);
					}
				}
			}

			return matrizRes;
    }

	//**********************************************************************

	function elementoHTML( id )
	{
		let elem = document.getElementById( id ) ;

		if ( ! elem )
			{
				alert('error: no hay en el documento un elemento html con identificador igual a "'+id+"'");
		   	exit() ;
			}
		return elem ;
	}
		
	// LLeva un punto del disco de Poincaré al modelo de Weierstrass
	function applyG(x, y){
		return  [[(2 * x) / (1 - x * x - y * y)],
			 [(2 * y) / (1 - x * x - y * y)],
		 	 [(1 + x * x + y * y) / (1 - x * x - y * y)]];
	}

	// LLeva un punto del modelo de Weierstrass al disco de Poincaré
	function applyF(x, y, z){
		return [[x / (1 + z)],
			[y / (1 + z)]];
	}
		
	//*******************************************************************************************

	function DrawPgonPattern(transformation){

		var
		Tvertex, oldTvertex, Tcenter;
		
		/// Centro del polígono
		let weierstrassCoordinatesCenter = applyG(centro0.x, centro0.y);

		let TCenter = matrixproduct(transformation, weierstrassCoordinatesCenter);

		Tcenter = applyF(TCenter[0][0], TCenter[1][0], TCenter[2][0]);

		Tcenter[0][0] = linealTransformation(Tcenter[0][0], escala, centro.x);
		Tcenter[1][0] = linealTransformation(Tcenter[1][0], escala, centro.y);

		for (i = 0; i < Action.length; i++){
			let weierstrassCoordinates = applyG(X[i], Y[i]);
				let Z = matrixproduct(transformation, weierstrassCoordinates);

				Tvertex = applyF(Z[0][0], Z[1][0], Z[2][0]);

				Tvertex[0][0] = linealTransformation(Tvertex[0][0], escala, centro.x);
				Tvertex[1][0] = linealTransformation(Tvertex[1][0], escala, centro.y);

				if (i != 0){
					/// Lados del polígono
					var lineaHiperbolica = new Circunferencia(oldTvertex[0][0], oldTvertex[1][0], Tvertex[0][0], Tvertex[1][0], ctx, centro, escala, "Black", 1);
					lineaHiperbolica.createHyperbolicLine();

					/// Radios del polígono
					var lineaHiperbolicaCenter = new Circunferencia(Tcenter[0][0], Tcenter[1][0], Tvertex[0][0], Tvertex[1][0], ctx, centro, escala, "#A4A4A4", 1);
					lineaHiperbolicaCenter.createHyperbolicLine();
			}

			oldTvertex = Tvertex;

			/*switch(Action[i]){
				case "Move":
					ctx.moveTo(Tx, Ty);
					//console.log(`ctx.moveTo(${Tx},${Ty})`)
					break;

				case "Draw":
					ctx.lineTo(Tx, Ty);
					//console.log(`ctx.lineTo(${Tx},${Ty})`)
					break;

				case "Black":
					ctx.strokeStyle = "Black";		//Pinta los bordes del polígono
					ctx.stroke();
					ctx.beginPath();
					//console.log(`Black == ctx.stroke() ; ctx.beginPath()`)
					break;

				case "Blue":
					ctx.strokeStyle = "Blue";
					ctx.stroke();
					ctx.beginPath();
					console.log(`Blue == ctx.stroke() ; ctx.beginPath()`)
					break;

				case "Red":
					ctx.strokeStyle = "Red";
					ctx.stroke();
					ctx.beginPath();
					console.log(`Red == ctx.stroke() ; ctx.beginPath()`)
					break;

				case "Yellow":
					ctx.strokeStyle = "Yellow";
					ctx.stroke();
					ctx.beginPath();
					console.log(`Yellow: == ctx.stroke() ; ctx.beginPath()`)
					break;
				default :
					throw RangeError(`Action[${i}] has an incorrect value`)
			}*/
		}
	}

	//*******************************************************************************************

	function ReplicatePatern(InitialTransformation, Layerdiff, Adyacency){
		let
		RotateCenter,
		RotateVertex,
		i, j,
		ExposedEdges,
		PgonsPerVertex;

		DrawPgonPattern(InitialTransformation);

		if (Layerdiff > 0){

			Rotate2P = matrixproduct(RotateP, RotateP);

			if (Adyacency == "Edge"){
				ExposedEdges = p - 3;
				Rotate3P = matrixproduct(Rotate2P, RotateP);

				RotateCenter = matrixproduct(InitialTransformation, Rotate3P);	//// Esto está en el artículo de 1986
			}

			else if (Adyacency == "Vertex"){
				ExposedEdges = p - 2;

				RotateCenter = matrixproduct(InitialTransformation, Rotate2P);		//// Esto está en el artículo de 1986
			}

			else {
				throw RangeError(`Adyacency has an incorrect value`);
			}

			for (i = 0; i < ExposedEdges; i++){
				RotateVertex = matrixproduct(RotateCenter, RotateQ);			/// Esto está en el artículo de 1986

				ReplicatePatern(RotateVertex,
						Layerdiff - 1,
						"Edge");			/// Esto está en el artículo de 1986


				if (i < ExposedEdges - 1)					//// El -1 es para compensar que la i empieza en 0
					PgonsPerVertex = q - 3;

				else if (i == ExposedEdges - 1)					//// El -1 es para compensar que la i empieza en 0
					PgonsPerVertex = q - 4;

			for(j = 0; j < PgonsPerVertex; j++){
				RotateVertex = matrixproduct(RotateVertex, RotateQ);
				ReplicatePatern(RotateVertex,
					Layerdiff - 1,
					"Vertex");
			}

			RotateCenter = matrixproduct(RotateCenter, RotateP);		/// Este for, junto con esta línea, están en el artículo de 1986

			}
		}
	}

//*******************************************************************************************
// función principal (la introduzco para poder poner 'return' antes de que acabe)

function main()
{
	var
	RotateCenter,
	RotateVertex;

	console.log(`main(): p == ${p}`)

	if ( X.length != Y.length || X.length != Action.length )
		throw RangeError(`las longitudes de X/Y/Action no coinciden, están mal definidas`)

	console.log(`X.length == ${X.length}, p == ${p}`)

	const long_X_orig = X.length;

 	DrawPgonPattern(Identity);


	if (nLayers > 0){					/// Para poder dibujar solo la primera capa (la capa 0)											// Artículo de 1981

		RotateCenter = Identity;

		for (let i = 0; i < p; i++){
			RotateVertex = matrixproduct(RotateCenter, RotateQ);

			ReplicatePatern(RotateVertex, nLayers - 1, "Edge");				// En el artículo de 1986 pone nLayers - 2, me parece más lógico con -1

			for (let j = 0; j < q - 3; j++){
				RotateVertex = matrixproduct(RotateVertex, RotateQ);
				ReplicatePatern(RotateVertex, nLayers - 1, "Vertex");			// En el artículo de 1986 pone nLayers - 2, me parece más lógico con -1
			}

			RotateCenter = matrixproduct(RotateCenter, RotateP);				// Artículo de 1986
		}
	}
}

//******************************************************************
// llamada a la función principal

main();

// Disco de Poincaré
ctx.beginPath();
ctx.arc(centro.x, centro.y, escala, 0, 2 * Math.PI, false);
ctx.strokeStyle = 'Blue';
ctx.stroke();

</script>
</body>
</html>
