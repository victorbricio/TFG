<!DOCTYPE html>
<html>
<head>
	<style>
		h1 {text-align: center;}
		ol {text-align: center;}
		p {text-align: center;}
</style>
</head>
<body>

	<h1> Hyperbolic Tessellations </h1>

	<ol type="i">
		<li><label for="p">Element p (number of edges the central polygon has):</label>
		<input type="number" id="p" name="p"></li> <br>

		<li><label for="q">Element q (number of polygons at each vertex):</label>
		<input type="number" id="q" name="q"></li> <br>

		<li><label for="n">Number of layers (number of tessellation layers):</label>
		<input type="number" id="n" name="n"></li> <br>

		<li><label for="n">Color 1 (use an English name or the hexadecimal code), by default is Red:</label>
		<input type="text" id="color1" name="color1"></li> <br>

		<li><label for="n">Color 2 (use an English name or the hexadecimal code), by default is Purple:</label>
		<input type="text" id="color2" name="color2"></li> <br>
	</ol>

	<p> Choose the kind of border </p>
	<p><input type="radio" id="boundary" name="border" value="0" checked>
	<label for="boundary">Boundary</label><br>
	<input type="radio" id="no boundary" name="border" value="1">
	<label for="no boundary">No boundary</label><br>
	<input type="radio" id="both" name="border" value="2">
	<label for="both">Both</label> <br><br>

	<input type="button" id=create value="Create"></p>

<p>
<canvas id="canvas1" width="1000" height="700"></canvas></td>
</p>
	<script type="text/javascript" src="Circunferencia.js"></script>
	<script type="text/javascript" src="Complex.js"></script>
	<script type="text/javascript" id="fuente">

	let p, q, nLayers, border;

	let centro, centro0, escala,

	canvas = document.getElementById('canvas1'),
	ctx = canvas.getContext('2d'),


	///// Variables globales de la geometria
	ReflectEdgeBisector,
	ReflectPgonEdge,
	cosh_b,
	RotateP,
	RotateQ,
	RotateEdge,
	Identity = [[1,0,0], [0,1,0], [0,0,1]];

	var X, Y, X1, Y1, Action;

	var color1, color2;

	elementoHTML("create").addEventListener("click", getTessellation, false);

	function getTessellation(){
		
		// Limpieza del canvas y de los vectores
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		X = [], Y = [], X1 = [], Y1 = [], Action = [];

		p = elementoHTML('p').value, q = elementoHTML('q').value, 		// parámetros p y q

		nLayers = elementoHTML('n').value;					// Capas a dibujar

		if (p == ""){
			p = 0;
		}

		if (q == ""){
			q = 0;
		}

		if (nLayers == ""){
			nLayers = 0;
		}

		border = document.querySelector('input[name="border"]:checked').value;

		p = Number(p);
		q = Number(q);
		nLayers = Number(nLayers);

		color1 = elementoHTML("color1").value;
		color2 = elementoHTML("color2").value;

		if (color1 == "")
			color1 = "Red";

		if (color2 == "")
			color2 = "Purple"

		if ((p - 2) * (q - 2) <= 4){
	  	window.alert("Tessellation {" + p + "," + q + "} is not hyperbolic.\n It must satisfy: (p - 2) * (q - 2) > 4");
			return ;
		}

		if (nLayers > 5){
			window.alert("Having a number of layers greater than 5 requieres too many resources, and you will not see any improvement.");
			return ;
		}

		 centro = {x: 500, y: 350},
		 centro0 = {x: 0, y: 0},		/// Centrar las rotaciones en el centro
		 escala = 300;

		 // Disco de Poincaré
		 ctx.beginPath();
		 ctx.arc(centro.x, centro.y, escala, 0, 2 * Math.PI, false);
		 ctx.strokeStyle = 'Blue';
		 ctx.stroke();

		if (border == 0 || border == 2){
			var vertice = verticePoligonoCentral();

			X.push(vertice.x);
			Y.push(vertice.y);
			//Action.push("Move");

			for (let i = 1; i < p + 1; i++){
				puntoRotado = rotatePoint(Y[0], X[0], 2 * Math.PI / p * i, centro0);
				Y.push(puntoRotado.x);
				X.push(puntoRotado.y);
			}
		}

		if (border == 1 || border == 2){
			let porcentajePequenyo = .1, porcentajeGrande = .8;

			if (p == 3)
				porcentajeGrande = 0.65;
			else if (p == 4)
				porcentajeGrande = 0.7;
			else if (p == 5)
				porcentajeGrande = 0.75;

			var vertice = verticePoligonoCentral();
			var vertice2 = rotatePoint(vertice.y, vertice.x, 2 * Math.PI / p, centro0);
			vertice2 = {x: vertice2.y, y: vertice2.x};
			var puntoMedio = {x: (vertice.x + vertice2.x) / 2, y: (vertice.y + vertice2.y) / 2};

			var punto1 = {x: vertice.x * porcentajePequenyo, y: vertice.y * porcentajePequenyo};
			var punto2 = {x: vertice.x * porcentajeGrande, y: vertice.y * porcentajeGrande};
			var punto3 = {x: puntoMedio.x * porcentajeGrande, y: puntoMedio.y * porcentajeGrande};
			punto1 = rotatePoint(punto1.x, punto1.y, -2 * Math.PI / p / 8, centro0);
			punto2 = rotatePoint(punto2.x, punto2.y, -2 * Math.PI / p / 8, centro0);
			punto3 = rotatePoint(punto3.x, punto3.y, 2 * Math.PI / p / 8, centro0);

			var punto4 = {x: vertice2.x * porcentajePequenyo, y: vertice2.y * porcentajePequenyo};
			var punto5 = {x: vertice2.x * porcentajeGrande, y: vertice2.y * porcentajeGrande};
			var punto6 = {x: puntoMedio.x * porcentajeGrande, y: puntoMedio.y * porcentajeGrande};
			punto4 = rotatePoint(punto4.x, punto4.y, 2 * Math.PI / p / 8, centro0);
			punto5 = rotatePoint(punto5.x, punto5.y, 2 * Math.PI / p / 8, centro0);
			punto6 = rotatePoint(punto6.x, punto6.y, -2 * Math.PI / p / 8, centro0);

			X1.push(punto1.x); X1.push(punto2.x); X1.push(punto3.x);
			X1.push(punto4.x); X1.push(punto5.x); X1.push(punto6.x);
			Y1.push(punto1.y); Y1.push(punto2.y); Y1.push(punto3.y);
			Y1.push(punto4.y); Y1.push(punto5.y); Y1.push(punto6.y);

			Action.push("Move"); Action.push("Draw"); Action.push("Draw");
			Action.push("Move"); Action.push("Draw"); Action.push("Draw");
		}


		let				//// Create ReflectEdgeBisector
		RB1 = [1,0,0],
		RB2 = [0,-1,0],
		RB3 = [0,0,1];

		ReflectEdgeBisector = [RB1, RB2, RB3],				//// End creation	/// ReflectQ para 1986

		cosh_b = Math.cos(Math.PI / q) / Math.sin(Math.PI / p);		//// Create ReflectPgonEdge

		let
		cosh_2b = 2 * cosh_b * cosh_b - 1,
		sinh_2b = Math.sqrt(cosh_2b * cosh_2b - 1),
		RPE1 = [-cosh_2b, 0, sinh_2b],
		RPE2 = [0, 1, 0],
		RPE3 = [-sinh_2b, 0, cosh_2b];

		ReflectPgonEdge = [RPE1, RPE2, RPE3];				//// End creation	/// ReflectP para el 1986

		let											/// Create ReflectHypotenuse
		RH1 = [Math.cos(2 * Math.PI / p), Math.sin(2 * Math.PI / p), 0],
		RH2 = [Math.sin(2 * Math.PI / p), - Math.cos(2 * Math.PI / p), 0],
		RH3 = [0, 0, 1];

		ReflectHypotenuse = [RH1, RH2, RH3];				/// End creation	// Reflect2 para 1986


		RotateP = matrixproduct(ReflectHypotenuse, ReflectEdgeBisector);		// 2 * Q
		RotateQ = matrixproduct(ReflectPgonEdge, ReflectHypotenuse);			// P * 2

		//******************************************************************
		// llamada a la función principal

		main();
	 }


	function verticePoligonoCentral(){
		let sin = Math.sin(Math.PI / p);
		let cos = Math.cos(Math.PI / q);
		let radio = 1 / Math.sqrt(((cos * cos) / (sin * sin)) - 1);
		let distancia_entre_centros = 1 / Math.sqrt(1 - ((sin * sin) / (cos * cos)));

		let t = Math.tan(Math.PI / p);
		let n = centro0.y - t * centro0.x;

		var a = 1 + t * t;
		var b = 2 * (- distancia_entre_centros + t * n);
		var c = distancia_entre_centros * distancia_entre_centros + n * n - radio * radio;

		var x1 = (- b + Math.sqrt( b * b - 4 * a * c)) / ( 2 * a);
		var y1 = t * x1 + n;

		var x2 = (- b - Math.sqrt( b * b - 4 * a * c)) / ( 2 * a);
		var y2 = t * x2 + n;

		var mod1 = (x1 - centro.x) * (x1 - centro.x) + (y1 - centro.y) * (y1 - centro.y);
		var mod2 = (x2 - centro.x) * (x2 - centro.x) + (y2 - centro.y) * (y2 - centro.y);

		var x;

		if (mod1 > mod2){
			x = {x: x1, y: y1};
		}

		else {
			x = {x: x2, y: y2};
		}

		return x;
	 }

	//**********************************************************************
	// Hace una transformacion lineal
	// Una homotecia con:
	// punto: el punto a trasladar
	// escala: la escala de la homotecia
	// centro: centro de la homotecia

	function linealTransformation(punto, escala, centro){
		return punto * escala + centro;
	}
		
		function linealTransformationInverse(punto, escala, centro){
		return (punto - centro) / escala;
	}

	  function getPoint01(punto, r, c){
	    var x = linealTransformationInverse(punto.x, r, c.x);
	    var y = linealTransformationInverse(punto.y, r, c.y);

	    var ret = {x:x, y:y};

	    return ret;
	  }

	  function MobiusTransformation(z, punto){
	    var zComp = new Complex(z.x, z.y);
	    var puntoComp = new Complex(punto.x, punto.y);
	    var uno = new Complex(1, 0);

	    var res = div(sub(zComp, puntoComp), sub(uno, prod(conjg(puntoComp), zComp)));
	    res = {x: res.re(), y: res.im()};

	    return res;
	  }

	  function MobiusTransformationBack(z, punto){
	    var zComp = new Complex(z.x, z.y);
	    var puntoComp = new Complex(punto.x, punto.y);
	    var uno = new Complex(1, 0);

	    var res = div(add(zComp, puntoComp), add(uno, prod(conjg(puntoComp), zComp)));
	    res = {x: res.re(), y: res.im()};

	    return res;
	  }

		// Obtiene el ángulo con la horizontal que tiene el punto (x,y) en una circunferencia de centro (cx, cy)
	  function angle(cx, cy, x, y) {
	     var dx = x - cx;
	     var dy = y - cy;
	     var theta = Math.atan2(dy, dx); // range (-PI, PI]

	     if (theta < 0)
		theta += 2 * Math.PI
	     return theta;
	   }

	//**********************************************************************

	// x e y: son las coordenadas del punto a rotar
	// alpha: es el ángulo en radianes que queremos rotar el punto
	// centro: es el centro de la rotación

	function rotatePoint(x, y, alpha, centro) {
		let sin = Math.sin(alpha);
		let cos = Math.cos(alpha);

		// Trasladar al centro
		x -= centro.x;
		y -= centro.y;

		// Rotar
		let newX = x * cos - y * sin;
		let newY = x * sin + y * cos;

		// Trasladar de vuelta
		let punto = {x: newX + centro.x, y: newY + centro.y};

		return punto;
	}


	//**********************************************************************

	// Supongo que mat1 es 3x3 y mat2 va a ser 3x3 o 3x1

	function matrixproduct( mat1, mat2 )
	{
		if (mat2[0].length == 3)
			var matrizRes = [[0,0,0], [0,0,0], [0,0,0]];

		else if (mat2[0].length == 1)
			var matrizRes = [[0], [0], [0]];

   		for (let i = 0; i < mat1.length; i++){
				for (let j = 0; j < mat2[0].length; j++){
					for (let k = 0; k < mat2.length; k++){
				 		matrizRes[i][j] += (mat1[i][k] * mat2[k][j]);
					}
				}
			}

			return matrizRes;
    }

	//**********************************************************************

	function elementoHTML( id )
	{
		let elem = document.getElementById( id ) ;

		if ( ! elem )
			{
				alert('error: no hay en el documento un elemento html con identificador igual a "'+id+"'");
		   	exit() ;
			}
		return elem ;
	}

	// Lleva un punto del disco de Poincaré al modelo de Weierstrass
	function applyG(x, y){
		return  [[(2 * x) / (1 - x * x - y * y)],
			 [(2 * y) / (1 - x * x - y * y)],
			 [(1 + x * x + y * y) / (1 - x * x - y * y)]];
	}

	// LLeva un punto del modelo de Weierstrass al disco de Poincaré
	function applyF(x, y, z){
		return [[x / (1 + z)],
			[y / (1 + z)]];
	}

	//*******************************************************************************************

	function DrawPgonPattern(transformation){

		var Tvertex, oldTvertex, Tcenter;

		/// Centro del polígono
		let weierstrassCoordinatesCenter = applyG(centro0.x, centro0.y);

		let TCenter = matrixproduct(transformation, weierstrassCoordinatesCenter);

		Tcenter = applyF(TCenter[0][0], TCenter[1][0], TCenter[2][0]);

		Tcenter[0][0] = linealTransformation(Tcenter[0][0], escala, centro.x);
		Tcenter[1][0] = linealTransformation(Tcenter[1][0], escala, centro.y);

		if (border == 0 || border == 2){
			for (let i = 0; i < X.length; i++){
				/// Vertices del polígono
				let weierstrassCoordinates = applyG(X[i], Y[i]);
				let Z = matrixproduct(transformation, weierstrassCoordinates);

				Tvertex = applyF(Z[0][0], Z[1][0], Z[2][0]);

				Tvertex[0][0] = linealTransformation(Tvertex[0][0], escala, centro.x);
				Tvertex[1][0] = linealTransformation(Tvertex[1][0], escala, centro.y);

				if (i != 0){
					/// Lados del polígono
					var lineaHiperbolica = new Circunferencia(oldTvertex[0][0], oldTvertex[1][0], Tvertex[0][0], Tvertex[1][0], ctx,
						centro, escala, color1, 1);
					lineaHiperbolica.drawHyperbolicLine();

					/// Radios del polígono
					var lineaHiperbolicaCenter = new Circunferencia(Tcenter[0][0], Tcenter[1][0], Tvertex[0][0], Tvertex[1][0], ctx, centro,
						escala, "Grey", 1);
					lineaHiperbolicaCenter.drawHyperbolicLine();
				}

				oldTvertex = Tvertex;
			}
		}

		if (border == 1 || border == 2){
			for (let i = 0; i < X1.length; i++){
				if (i == 0)
					ctx.beginPath();
				let weierstrassCoordinates = applyG(X1[i], Y1[i]);
				let Z1 = matrixproduct(transformation, weierstrassCoordinates);

				Tvertex = applyF(Z1[0][0], Z1[1][0], Z1[2][0]);

				Tvertex[0][0] = linealTransformation(Tvertex[0][0], escala, centro.x);
				Tvertex[1][0] = linealTransformation(Tvertex[1][0], escala, centro.y);

				switch(Action[i]){
					case "Move":
						ctx.moveTo(Tvertex[0][0], Tvertex[1][0]);
						//console.log(`ctx.moveTo(${Tvertex[0][0]},${Tvertex[1][0]})`)
						break;

					case "Draw":
						ctx.lineTo(Tvertex[0][0], Tvertex[1][0]);
						//console.log(`ctx.lineTo(${Tvertex[0][0]},${Tvertex[1][0]})`)
						break;

					default:
						ctx.strokeStyle = Action[i];
						ctx.stroke();
						if (i != X1.length)
							ctx.beginPath();
						//console.log(`Black == ctx.stroke() ; ctx.beginPath()`)
						break;
				}
			}
		}

	}

	//*******************************************************************************************

	function ReplicatePattern(InitialTransformation, Layerdiff, Adyacency){
		let
		RotateCenter,
		RotateVertex,
		i, j,
		ExposedEdges,
		PgonsPerVertex;

		DrawPgonPattern(InitialTransformation);

		if (Layerdiff > 0){

			var Rotate2P = matrixproduct(RotateP, RotateP);

			if (Adyacency == "Edge"){
				ExposedEdges = p - 3;
				var Rotate3P = matrixproduct(Rotate2P, RotateP);

				RotateCenter = matrixproduct(InitialTransformation, Rotate3P);
			}

			else if (Adyacency == "Vertex"){
				ExposedEdges = p - 2;

				RotateCenter = matrixproduct(InitialTransformation, Rotate2P);
			}

			else {
				throw RangeError(`Adyacency has an incorrect value`);
			}

			for (i = 0; i < ExposedEdges; i++){
				RotateVertex = matrixproduct(RotateCenter, RotateQ);

				ReplicatePattern(RotateVertex,
						Layerdiff - 1,
						"Edge");

				//RotateCenter = matrixproduct(RotateP, RotateCenter);		/// Esto está en el artículo de 1981

				if (i < ExposedEdges - 1)					//// El -1 es para compensar que la i empieza en 0
					PgonsPerVertex = q - 3;

				else if (i == ExposedEdges - 1)					//// El -1 es para compensar que la i empieza en 0
					PgonsPerVertex = q - 4;

			for(j = 0; j < PgonsPerVertex; j++){
				RotateVertex = matrixproduct(RotateVertex, RotateQ);
				ReplicatePattern(RotateVertex,
					Layerdiff - 1,
					"Vertex");
			}

			RotateCenter = matrixproduct(RotateCenter, RotateP);

			}
		}
	}

	//*******************************************************************************************
	// función principal (la introduzco para poder poner 'return' antes de que acabe)

	function main()
	{
		var
		RotateCenter,
		RotateVertex;

		console.log(`main(): p == ${p}`);

		if (border == 1 || border == 2){
			// Le añado un (0,0) a los puntos puesto que cuando llegue a este punto se eligirá el color
			X1.push(0);
			Y1.push(0);
			Action.push(color2);

			const long_X_orig = X1.length;

			if ( X1.length != Y1.length || X1.length != Action.length )
				throw RangeError(`las longitudes de X/Y/Action no coinciden, están mal definidas`);

			 /// Añado las rotaciones a los vectores X e Y (y Action)
			 for (let i = 1; i < p; i++){ 
				 for (let j = 0; j < long_X_orig; j++){
					 let puntoRotado = {x:0, y:0};

					 if (j != long_X_orig - 1)				// Cuando sea color, se añade el punto (0,0)
							puntoRotado = rotatePoint(X1[j], Y1[j], 2 * Math.PI / p * i, centro0);

					 X1.push(puntoRotado.x);
					 Y1.push(puntoRotado.y);
					 Action.push(Action[j]) ;
				 }
			 }
		 }
		
	DrawPgonPattern(Identity);




	if (nLayers > 0){					/// Para poder dibujar solo la primera capa (la capa 0)

		RotateCenter = Identity;

		for (let i = 0; i < p; i++){
			RotateVertex = matrixproduct(RotateCenter, RotateQ);

			ReplicatePattern(RotateVertex, nLayers - 1, "Edge");				// En el artículo de 1986 pone nLayers - 2, me parece más lógico con -1

			for (let j = 0; j < q - 3; j++){
				RotateVertex = matrixproduct(RotateVertex, RotateQ);
				ReplicatePattern(RotateVertex, nLayers - 1, "Vertex");			// En el artículo de 1986 pone nLayers - 2, me parece más lógico con -1
			}

			RotateCenter = matrixproduct(RotateCenter, RotateP);
			}
		}
	}

</script>
</body>
</html>
